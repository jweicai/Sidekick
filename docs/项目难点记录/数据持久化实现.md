# 数据持久化实现

## 需求背景

用户反馈：每次重启应用后，之前加载的数据表都消失了，需要重新加载，体验不好。

**需求**：应用应该记住用户加载过的文件，重启后自动恢复这些表。

## 设计方案

### 方案选择

考虑了以下几种方案：

1. **SQLite 持久化数据库**
   - 优点：可以存储完整的数据
   - 缺点：数据可能过期，文件更新后不同步，占用存储空间

2. **保存文件路径，重新加载**（✅ 采用）
   - 优点：始终使用最新的文件数据，实现简单
   - 缺点：文件移动或删除后会失败

3. **Core Data**
   - 优点：Apple 官方框架
   - 缺点：对于简单的路径存储来说过于复杂

**最终选择**：方案 2 - 保存文件路径，启动时重新加载

### 实现细节

#### 1. 数据结构

```swift
/// 持久化的表信息（用于保存到 UserDefaults）
struct PersistedTableInfo: Codable {
    let name: String           // SQL 表名 (table1, table2, ...)
    let displayName: String    // 显示名称
    let sourceURLPath: String  // 文件路径
}
```

#### 2. 存储位置

使用 `UserDefaults` 存储：
- Key: `"TableQuery.LoadedTables"`
- 格式: JSON 编码的 `[PersistedTableInfo]` 数组

#### 3. 核心方法

**保存表信息**：
```swift
private func saveTables() {
    let persistedTables = loadedTables.map { table in
        PersistedTableInfo(
            name: table.name,
            displayName: table.displayName,
            sourceURLPath: table.sourceURL.path
        )
    }
    
    if let encoded = try? JSONEncoder().encode(persistedTables) {
        UserDefaults.standard.set(encoded, forKey: persistenceKey)
    }
}
```

**加载表信息**：
```swift
private func loadPersistedTables() {
    guard let data = UserDefaults.standard.data(forKey: persistenceKey),
          let persistedTables = try? JSONDecoder().decode([PersistedTableInfo].self, from: data) else {
        return
    }
    
    for persistedTable in persistedTables {
        let url = URL(fileURLWithPath: persistedTable.sourceURLPath)
        
        // 检查文件是否还存在
        guard FileManager.default.fileExists(atPath: url.path) else {
            print("⚠️ File not found: \(url.path)")
            continue
        }
        
        // 重新加载文件
        do {
            let dataFrame = try loaderManager.loadFile(from: url)
            let table = LoadedTable(
                name: persistedTable.name,
                displayName: persistedTable.displayName,
                dataFrame: dataFrame,
                sourceURL: url
            )
            loadedTables.append(table)
        } catch {
            print("❌ Failed to load: \(error)")
        }
    }
}
```

#### 4. 触发时机

**保存时机**：
- 加载新文件后
- 移除表后

**加载时机**：
- MainViewModel 初始化时（`init()`）

**清除时机**：
- 用户点击"清除所有数据"时

## 实现步骤

### 1. 添加持久化数据结构

在 `MainViewModel.swift` 中添加 `PersistedTableInfo` 结构体。

### 2. 添加持久化方法

实现三个私有方法：
- `saveTables()` - 保存到 UserDefaults
- `loadPersistedTables()` - 从 UserDefaults 加载
- `clearPersistedTables()` - 清除持久化数据

### 3. 在适当时机调用

- `init()` 中调用 `loadPersistedTables()`
- `loadFile()` 成功后调用 `saveTables()`
- `removeTable()` 后调用 `saveTables()`
- `clearData()` 中调用 `clearPersistedTables()`

## 错误处理

### 文件不存在

如果保存的文件路径不存在：
- 跳过该文件
- 打印警告日志
- 继续加载其他文件

### 文件加载失败

如果文件格式变化或损坏：
- 捕获异常
- 打印错误日志
- 继续加载其他文件

### 解码失败

如果 UserDefaults 数据损坏：
- 返回空数组
- 不影响应用启动

## 用户体验

### 正常流程

1. 用户加载文件 A、B、C
2. 关闭应用
3. 重新打开应用
4. 自动加载 A、B、C，恢复到之前的状态

### 异常情况

**文件被移动**：
- 应用启动时显示警告
- 跳过该文件
- 其他文件正常加载

**文件被删除**：
- 应用启动时显示警告
- 跳过该文件
- 其他文件正常加载

**文件内容变化**：
- 重新解析文件
- 使用最新的数据
- 类型推断可能变化

## 优化建议

### 当前实现的限制

1. **同步加载**：启动时同步加载所有文件，可能导致启动慢
2. **无进度提示**：用户不知道正在恢复数据
3. **无错误提示**：文件加载失败时只有控制台日志

### 未来改进

1. **异步加载**：
   ```swift
   private func loadPersistedTables() {
       DispatchQueue.global(qos: .userInitiated).async {
           // 后台加载文件
           DispatchQueue.main.async {
               // 更新 UI
           }
       }
   }
   ```

2. **加载进度**：
   - 显示"正在恢复数据..."提示
   - 显示加载进度（X/Y 个文件）

3. **错误提示**：
   - 弹出对话框告知用户哪些文件加载失败
   - 提供"移除失效文件"选项

4. **智能恢复**：
   - 记录文件的修改时间
   - 如果文件未变化，可以缓存解析结果

5. **文件监控**：
   - 使用 `FileManager` 监控文件变化
   - 文件更新时自动重新加载

## 测试验证

### 功能测试

- ✅ 加载文件后重启，数据恢复
- ✅ 移除表后重启，表不再出现
- ✅ 清除数据后重启，无数据
- ✅ 文件被删除后重启，跳过该文件
- ✅ 文件被移动后重启，跳过该文件

### 边界测试

- ✅ 首次启动（无持久化数据）
- ✅ UserDefaults 数据损坏
- ✅ 加载大量文件（性能）
- ✅ 文件路径包含特殊字符

## 技术要点

### UserDefaults 使用

```swift
// 保存
UserDefaults.standard.set(data, forKey: key)

// 读取
UserDefaults.standard.data(forKey: key)

// 删除
UserDefaults.standard.removeObject(forKey: key)
```

### JSON 编解码

```swift
// 编码
let data = try JSONEncoder().encode(object)

// 解码
let object = try JSONDecoder().decode(Type.self, from: data)
```

### 文件存在检查

```swift
FileManager.default.fileExists(atPath: path)
```

## 总结

通过保存文件路径并在启动时重新加载的方式，实现了简单有效的数据持久化：

**优点**：
- ✅ 实现简单，代码量少
- ✅ 始终使用最新的文件数据
- ✅ 不占用额外存储空间
- ✅ 支持文件更新自动同步

**缺点**：
- ⚠️ 文件移动或删除后会失败
- ⚠️ 启动时需要重新解析文件
- ⚠️ 大量文件时启动可能较慢

对于 TableQuery 这样的轻量级工具，这个方案是合适的。未来可以根据用户反馈进行优化。

---

**实现日期**: 2025-01-13  
**版本**: 1.2.0  
**状态**: ✅ 已完成
